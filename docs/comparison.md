# awrshift vs Other Frameworks

awrshift is not a coding framework. It's a thinking layer for decisions.

Other frameworks help you write code. awrshift helps you make the right decisions before writing a single line. Choose the wrong architecture, and no framework will save you. Choose the right one, and any framework will work.

Stop optimizing the build. Start optimizing the decision.

---

## Outcome Comparison

Forget feature checklists. Here's what actually changes when you use each framework:

| | awrshift | BMAD Method | Superpowers | Spec Kit |
|---|---------|-------------|-------------|----------|
| **Before you build** | 3 research phases. You know the problem, the evidence, and the success bar. | Role-based agents discuss scope | Jump to coding | Write a spec from requirements |
| **During build** | VERIFY (Fact-check the plan) blocks IMPLEMENT (Build it). Your plan is evidence-checked. | Agile sprints with agent roles | AI generates code | AI follows the spec |
| **After you build** | EVALUATE (Score against the bar) measures results against predefined metrics. Ship, iterate, or rollback. | Sprint retrospective | Manual review | Compare to spec |
| **Who decides** | You. 5-6 explicit checkpoints. The AI proposes. You approve. Every time. | Team roles | You review output | You review output |
| **Works beyond code** | Yes. Schools, moves, hiring, strategy, product naming. Any decision with stakes. | No — software only | No — code only | No — software only |
| **Setup** | Copy 1 markdown file | Clone repo + configure agents | Clone repo | Clone repo |

---

## When to Use What

### awrshift — when the decision matters more than the code

The decision IS the hard part. The code is just execution.

- Choosing between architectures (microservices vs monolith, Postgres vs DynamoDB)
- Naming a product or positioning a brand
- Planning a move to a new city
- Deciding which school for your kid
- Hiring strategy when three candidates are strong
- Any decision where being wrong is expensive

awrshift won't write your code. It will make sure you write the right code.

### BMAD Method — when you need a team structure for building

You already know what to build. You need organized execution.

- Full software delivery with role-based agents (PM, architect, dev)
- Agile ceremonies matter to your workflow
- Sprint planning, retrospectives, team coordination

### Superpowers — when you want better code generation

The decision is made. You need faster, better code.

- Coding productivity and pre-built skills
- Common coding tasks with optimized prompts
- Focus is on output quality, not decision quality

### Spec Kit — when requirements are clear and you need implementation

Someone already decided. Now you need it built.

- Detailed specifications exist
- Requirements are locked. Challenge is implementation.
- Spec-to-plan-to-code automation

---

## Combine awrshift with Others

awrshift is a thinking layer. It sits above execution frameworks, not beside them.

Think of it this way: awrshift decides WHAT and WHY. Other frameworks handle HOW.

| Combination | How it works | When this wins |
|-------------|-------------|----------------|
| **awrshift + BMAD** | awrshift runs IDENTIFY (Name the problem) through DECIDE (Ship, iterate, or rollback). Once you know what to build, BMAD takes over for sprint execution within IMPLEMENT (Build it). | You need structured decisions AND organized team execution. The research phases prevent building the wrong thing. BMAD prevents building the right thing badly. |
| **awrshift + Superpowers** | awrshift handles IDENTIFY (Name the problem) through PLAN (Map it out) — research, hypotheses, evaluation criteria. Superpowers handles coding tasks within the IMPLEMENT (Build it) phase. | You need evidence-based planning AND high-quality code generation. awrshift makes sure you're solving the right problem. Superpowers makes sure the code is clean. |
| **awrshift + Spec Kit** | awrshift decides WHAT to build through HYPOTHESIZE (Pick your best guess) and EVAL-DESIGN (Set the bar). Spec Kit generates the detailed spec that feeds into PLAN (Map it out). | Requirements aren't clear yet. awrshift's research phases crystallize what you actually need. Then Spec Kit automates the spec-to-code pipeline. |
| **awrshift alone** | Full standalone framework. No dependencies. Works for coding decisions, life decisions, strategy, hiring — anything with stakes. One markdown file, any AI assistant. | The decision IS the deliverable. No code needed. Or the project is small enough that one person handles both thinking and building. |

The pattern is always the same: **awrshift for the brain work. Other frameworks for the hand work.**

---

## What Makes awrshift Different

### 1. Research is mandatory, not optional

Most frameworks trust the AI's memory. awrshift doesn't.

IDENTIFY (Name the problem), FORMULATE (Ask the right questions), RESEARCH (Find the evidence) — three phases before you even propose a solution. Your AI investigates the real world. Official docs, benchmarks, primary sources. Not training data from two years ago.

You wouldn't make a $100K hiring decision on a gut feeling. Don't make architecture decisions that way either.

### 2. Success criteria come before the build

EVAL-DESIGN (Set the bar) defines how you'll measure success before you write a line of code. Specific metrics. Specific thresholds. Sourced from real data.

No more "it feels good enough." You know the bar. You either clear it or you don't.

### 3. Checkpoints are structural, not suggestions

awrshift doesn't suggest you review the plan. It blocks execution until you approve.

Five checkpoints in Standard mode. Six in Scientific. FORMULATE (Ask the right questions), HYPOTHESIZE (Pick your best guess), EVAL-DESIGN (Set the bar), PLAN (Map it out), DECIDE (Ship, iterate, or rollback) — and COMPARE (Pick the winner) in Scientific mode. Your AI pauses and waits. Every time.

You're not reviewing output. You're steering the process.

### 4. Leveling up is built in

Start with Quick mode — 3 phases, 5 minutes. Discover unknowns? Level up to Standard — 11 phases, full research. Multiple viable options? Level up to Scientific — 13 phases, test them all with the same criteria.

The framework grows with the problem. You don't commit to heavyweight process for a config change. You don't wing it on a critical architecture decision.

### 5. Works beyond code

awrshift handles product decisions, marketing strategy, hiring processes, architecture reviews, school choices, city moves — anything where structured thinking with evidence beats guessing.

One framework. Every decision. No domain restrictions.

---

## The Non-Technical Frame

**awrshift is for decisions. Others are for code.**

If your bottleneck is code quality — use Superpowers. If your bottleneck is team coordination — use BMAD. If your bottleneck is spec-to-code automation — use Spec Kit.

But if your bottleneck is making the right call? If you've ever shipped the wrong feature, picked the wrong tool, or realized too late that nobody validated the assumption?

That's awrshift territory.

One file. Any AI. Every decision that matters.

---

*awrshift is not a replacement. It's a layer. Think first, build with whatever tools you want.*
